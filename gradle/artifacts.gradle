/*******************************************************************************
 * The John Operating System Project is the collection of software and configurations
 * to generate IoT EcoSystem, like the John Operating System Platform one.
 * Copyright (C) 2021 Roberto Pompermaier
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 ******************************************************************************/


import com.robypomper.build.commons.Naming
import com.robypomper.build.java.JavaPublicationUtils
import com.robypomper.build.gradle.GradleBuildInfo

import java.text.SimpleDateFormat

/**
 * Project's artifacts' definitions from their sourceSets until their publications.
 */


// ------------------
// Components configs
// ------------------

sourceSets {}

configurations {}

dependencies {
    implementation "com.robypomper.josp:jospCommons:${project.ext.get("version.deps.jospCommons")}"
    implementation "commons-cli:commons-cli:${project.ext.get("version.cli")}"
    implementation "com.googlecode.clichemaven:cliche:${project.ext.get("version.cliche")}"
    implementation "net.sourceforge.htmlcleaner:htmlcleaner:${project.ext.get("version.htmlcleaner")}"
    implementation "com.jayway.jsonpath:json-path:${project.ext.get("version.json-path")}"
    implementation "org.slf4j:slf4j-nop:${project.ext.get("version.slf4j")}"
}

GradleBuildInfo.makeBuildInfoForSourceSet(project, sourceSets.main, (String) project.ext.get("artifactVersion"));


// -------------
// Runners Tasks
// -------------

boolean isDaemon = false
boolean overrideIfExist = false
String FileConfigs_JOD = "src/main/configs/jod_default.yml"
String FileConfigs_Struct = "src/main/configs/struct_default.jod"
String FileConfigs_Perms = "src/main/configs/perms_default.jod"
String FileConfigs_Log4j2 = 'src/main/configs/log4j2/log4j2.xml'
File WorkingDir = file("envs/runnables/jod")
String MainClass = !hasProperty('artifactMainClass')
        ? null
        : isDaemon
        ? ext.get('artifactMainClass')
        : ext.get('artifactMainClass').replace("JODDaemon", "JODShell")

tasks.run {
    classpath(sourceSets.main.getRuntimeClasspath());

    setWorkingDir(WorkingDir);
    doFirst {
        if (!WorkingDir.exists())
            WorkingDir.mkdirs();
    };

    if (MainClass != null)
        setMain(MainClass)

    jvmArgs = [
            '-Dlog4j.configurationFile=' + project.file(FileConfigs_Log4j2).absolutePath,
            //'-Djavax.net.debug=ssl'],
    ]
    args = [
            //'--configs', 'src/jospJOD/configs/jod_dev.yml',
    ]

    standardInput = System.in

    doFirst {
        if (WorkingDir.exists() && overrideIfExist)
            delete WorkingDir

        if (!WorkingDir.exists())
            copy {
                from FileConfigs_JOD
                rename 'jod(.+).yml', 'jod.yml'
                from FileConfigs_Struct
                rename 'struct(.+).jod', 'struct.jod'
                from FileConfigs_Perms
                rename 'perms(.+).jod', 'perms.jod'
                from FileConfigs_Log4j2
                rename 'log4j2(.+).xml', 'log4j2.xml'
                into "$WorkingDir/configs"
            }
    }
}

tasks.clean.doFirst {
    group 'JOSP cleaners'
    delete WorkingDir
}


// -------------------
// Publication configs
// -------------------

String pubName = ext.get('artifactLongName')
String pubArtifact = ext.get('artifactName')
String pubDescription = ext.get('artifactDescription')
String pubGroupId = ext.get('artifactGroupId')
String pubVersion = ext.get('artifactVersion')
String pubUrl = ext.get('projectUrl')
String pubGit = ext.get('projectGit')
String pubGitUrl = ext.get('projectGitUrl')
String pubLicence = ext.get('artifactLicence')
String pubLicenceUrl = ext.get('artifactLicenceUrl')
String pubMainClass = hasProperty('artifactMainClass') ? ext.get('artifactMainClass') : null
SourceSet pubSourcesSet = sourceSets.main

tasks.jar {
    doFirstArchiveBaseName(it, pubArtifact);

    //from(jospJODSourcesSet.getOutput());

    getManifest().attributes(prepareManifestAttributes(pubSourcesSet, pubName, pubVersion, pubLicence, pubLicenceUrl, pubMainClass, ""));
}

tasks.register("jarDeps", org.gradle.jvm.tasks.Jar.class) {
    setGroup(BasePlugin.BUILD_GROUP);
    setClassifier(JavaPublicationUtils.CLASSIFIER_DEP);
    doFirstArchiveBaseName(it, pubArtifact);

    List<File> fs = new ArrayList<>();
    for (File f : pubSourcesSet.getRuntimeClasspath())
        if (f.exists() && !f.isDirectory())
            fs.add(f);
    from(fs);

    getManifest().attributes(prepareManifestAttributes(pubSourcesSet, pubName, pubVersion, pubLicence, pubLicenceUrl, pubMainClass, ""));
}

tasks.javadoc {
    setTitle(String.format("%s JavaDocs", Naming.capitalize(pubName)));

    FileCollection classPath = it.getClasspath();
    classPath = classPath.plus(pubSourcesSet.getRuntimeClasspath());
    classPath = classPath.plus(project.files(pubSourcesSet.getCompileClasspath().getFiles()));
    classPath = classPath.plus(pubSourcesSet.getAnnotationProcessorPath());
    setClasspath(classPath);

    setFailOnError(false);

    enabled = !project.ext.get("disableDocs");
}

tasks.register("jarDocs", org.gradle.jvm.tasks.Jar.class) {
    setGroup(BasePlugin.BUILD_GROUP);
    setClassifier(JavaPublicationUtils.CLASSIFIER_DOC);
    doFirstArchiveBaseName(it, pubArtifact);

    from(tasks.javadoc.getOutputs());

    enabled = !project.ext.get("disableDocs");

    getManifest().attributes(prepareManifestAttributes(pubSourcesSet, pubName, pubVersion, pubLicence, pubLicenceUrl, pubMainClass, ""));
}

tasks.register("jarSrc", org.gradle.jvm.tasks.Jar.class) {
    setGroup(BasePlugin.BUILD_GROUP);
    setClassifier(JavaPublicationUtils.CLASSIFIER_SRC);
    doFirstArchiveBaseName(it, pubArtifact);

    from(pubSourcesSet.getAllSource());

    getManifest().attributes(prepareManifestAttributes(pubSourcesSet, pubName, pubVersion, pubLicence, pubLicenceUrl, pubMainClass, ""));
}

publishing {
    publications {
        "$pubArtifact"(MavenPublication) {
            groupId = pubGroupId
            artifactId = pubArtifact
            version = pubVersion

            artifact jar
            artifact jarDeps
            artifact jarDocs
            artifact jarSrc
        }
    }
}
def pub_pom = publishing.publications."$pubArtifact".getPom()
JavaPublicationUtils.initPom(pub_pom, pubName, pubDescription, pubUrl, pubGit, pubGitUrl, pubLicence, pubLicenceUrl);
def pub_configs = configurations.getByName(pubSourcesSet.getImplementationConfigurationName())
JavaPublicationUtils.injectDependenciesToPom(pub_pom, pub_configs, true);



// -------------
// Utils methods
// -------------

static void doFirstArchiveBaseName(final org.gradle.jvm.tasks.Jar jarTask, String baseName) {
    jarTask.doFirst(new Action<Task>() {
        @Override
        public void execute(Task task) {
            jarTask.setBaseName(baseName);
        }
    });
}

static Map<String, String> prepareManifestAttributes(SourceSet sourceSet, String name, String version, String licence, String licenceUrl, String mainClass, String nameExtension) {
    //@formatter:off
    Map<String, String> res = new HashMap<>();
    res.put("Implementation-Title"      , name + (nameExtension.isEmpty() ? "" : " - " + Naming.capitalize(nameExtension)));
    res.put("Implementation-Version"    , version);
    res.put("Implementation-Variant"    , (nameExtension.isEmpty() ? "default" : " - " + Naming.capitalize(nameExtension)));

    res.put("Licence"                   , licence);
    res.put("Licence-Url"               , licenceUrl);

    if (mainClass != null)
        res.put("Main-Class"            , mainClass);

    res.put("Built-By"                  , System.getProperty("user.name"));
    res.put("Build-Timestamp"           , new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ").format(new Date()));
    res.put("Created-By"                , String.format("Gradle %s", System.getProperty("gradle.gradleVersion}")));
    res.put("Build-Jdk"                 , String.format("%s (%s %s)", System.getProperty("java.version"), System.getProperty("java.vendor"), System.getProperty("java.vm.version")));
    res.put("Build-OS"                  , String.format("%s %s %s", System.getProperty("os.name"), System.getProperty("os.arch"), System.getProperty("os.version")));
    StringBuilder classPath = new StringBuilder();
    for (File f : sourceSet.getRuntimeClasspath().getFiles())
        if (f.getName().endsWith(".jar"))
            classPath.append(String.format("libs/%s ", f.getName()));
    res.put("Class-Path"                , classPath.toString());

    //res.put("Build-Revision"            : versioning.info.commit);
    //@formatter:on
    return res;
}
